# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'secondTry.ui'
#
# Created by: PyQt5 UI code generator 5.14.0
#
# WARNING! All changes made in this file will be lost!

#run this with sudo -E python3 secondTry.py


import sys
import os
import time
from tkinter.font import BOLD
from tkinter.tix import Tree
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import *
from my_app import *
from PyQt5.QtWidgets import QMessageBox, QWidget, QHeaderView
from PyQt5.Qt import QStandardItemModel, QStandardItem
from PyQt5.QtGui import QFont, QColor, QMovie, QPixmap, QPainter, QIcon
from functools import partial
from vulnersAPI.vulnUsage  import *
from fpdf import FPDF
from datetime import datetime

activeIPs = []
foundIPs = []
foundPorts = []
portsDictionary = {}
portsToBeFurtherScanned = []
today = datetime.now()

pdf = FPDF()
currentLine = 1
pdf.add_page()
pdf.set_font("Arial", size=13)

pdf.cell(200,10, txt="Scan Report", ln=currentLine, align='C')
currentLine+=1




class StandardItem(QStandardItem):
    def __init__(self, txt='', font_size=12, set_bold=False, color=QColor(0,0,0)):
        super().__init__()

        fnt = QFont('Open Sans', font_size)
        fnt.setBold(set_bold)
        #paint = QPainter()
        #TODO: might be able to add a loading circle on each standard item with QSvgRenderer on a QPainter?
        self.setEditable(False)
        self.setForeground(color)
        self.setFont(fnt)
        self.setText(txt)

    def getText(self):
        try:
            return self.text()
        except Exception as ex:
            print("Cannot get text from StandardItem because of exception: ", ex)

def getIndex(li, target):
    for index, x in enumerate(li):
        if x.getText() == target:
            return index
    return -1

def printList(li, target):
    print("PRINTING FOUNDPORTS")
    for index, x in enumerate(li):
        print(x.getText())
    return -1

class LoadingScreen(QWidget):
    def __init__(self):
        super().__init__()
        self.setFixedSize(441,221)
        self.setWindowFlags(Qt.WindowStaysOnTopHint | Qt.CustomizeWindowHint)

        self.label_animation = QtWidgets.QLabel(self)
        self.movie = QMovie('Loading_icon.gif')
        self.label_animation.setMovie(self.movie)

        
    
    def startAnimation(self):
        self.movie.start()
        self.show()

    def stopAnimation(self):
        self.movie.stop()
        self.close()


class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.showMaximized()

        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")

        #grid layout for input
        self.gridLayoutWidget = QtWidgets.QWidget(self.centralwidget)
        self.gridLayoutWidget.setGeometry(QtCore.QRect(20, 30, 261, 81))
        self.gridLayoutWidget.setObjectName("gridLayoutWidget")

        self.gridLayout = QtWidgets.QGridLayout(self.gridLayoutWidget)
        self.gridLayout.setContentsMargins(0, 0, 0, 0)
        self.gridLayout.setObjectName("gridLayout")

        #input field for network to scan
        self.inputNetwork = QtWidgets.QLineEdit(self.gridLayoutWidget)
        self.inputNetwork.setObjectName("inputNetwork")
        self.gridLayout.addWidget(self.inputNetwork, 1, 0, 1, 2)

        self.networkLabel = QtWidgets.QLabel(self.gridLayoutWidget)
        self.networkLabel.setObjectName("networkLabel")
        self.gridLayout.addWidget(self.networkLabel, 0, 0, 1, 2)

        #button for submitting network to scan
        self.submitNetworkButton = QtWidgets.QPushButton(self.gridLayoutWidget, clicked= lambda: self.submitNetworkClick())
        self.submitNetworkButton.setObjectName("submitNetworkButton")
        self.gridLayout.addWidget(self.submitNetworkButton, 2, 1, 1, 1)

        #tree view of the active ips
        self.treeView = QtWidgets.QTreeView(self.centralwidget)
        self.treeView.setGeometry(QtCore.QRect(350, 30, 1001, 751))
        self.treeView.setObjectName("treeView")
        self.treeView.setHeaderHidden(False)
        self.treeView.setWordWrap(True)
        self.treeView.setAlternatingRowColors(True)
        # self.treeView.setSortingEnabled(True)
        self.treeModel = QStandardItemModel(self.treeView)
        self.rootNode = self.treeModel.invisibleRootItem()
        self.treeView.doubleClicked.connect(self.doubleClickOnValueFromTree)
        self.treeView.setAnimated(True)
        
        headerIcon = QIcon("Cyber-Security-PNG.png")
        scanResults = QStandardItem(headerIcon, "Scan Results")
        scanResults.setTextAlignment(Qt.AlignHCenter)
        self.treeModel.setHorizontalHeaderItem(0, scanResults)

        self.headerModel = QStandardItemModel()
        self.headerModel.setHeaderData(0, QtCore.Qt.Horizontal, "Scan Results")
        self.headerModel.setHeaderData(1, QtCore.Qt.Horizontal, "Scan ")
        self.treeView.header().setModel(self.headerModel)

        self.loadIcon = QIcon("loading.gif")
        self.cyberIcon = QIcon("Cyber-Security-PNG.png")
        # self.treeView.horizontalHeader().setSectionResizeMode(0, QHeaderView.Stretch)
        
        #TODO: Put additional data like a pixmap on the treemodel: https://forum.qt.io/topic/53029/solved-how-can-i-get-row-and-col-of-my-child-in-qtreeview/9
        
        #response on network input
        self.networkValidationLabel = QtWidgets.QLabel(self.centralwidget)
        self.networkValidationLabel.setGeometry(QtCore.QRect(20, 110, 261, 51))
        self.networkValidationLabel.setWordWrap(True)
        self.networkValidationLabel.setObjectName("networkValidationLabel")

        self.loadingLabel = QtWidgets.QLabel(self.centralwidget)
        self.loadingLabel.setGeometry(QtCore.QRect(40,140, 200, 200))
        self.loadingLabel.setObjectName("loadingLabel")
        self.movie = QMovie('loading.gif')
        self.movie.setScaledSize(QSize().scaled(100, 100, Qt.KeepAspectRatio))
        self.loadingLabel.setMovie(self.movie)
        # self.loadingLabel.setText("Scanning. Please wait")
        # self.loadingLabel.adjustSize()
        self.loadingLabel.hide()

        self.fullScanCheckBox = QtWidgets.QCheckBox(self.centralwidget)
        self.fullScanCheckBox.setGeometry(QtCore.QRect(20, 170, 201, 23))
        self.fullScanCheckBox.setObjectName("fullScanCheckBox")
        self.fullScanCheckBox.setText("Search all ports for a syn reply")
        self.fullScanCheckBox.adjustSize()
        self.fullScanCheckBox.hide()

        self.detailedScanCheckBox = QtWidgets.QCheckBox(self.centralwidget)
        self.detailedScanCheckBox.setGeometry(QtCore.QRect(20, 190, 201, 23))
        self.detailedScanCheckBox.setObjectName("detailedScanCheckBox")
        self.detailedScanCheckBox.setText("Check details after discovering ports")
        self.detailedScanCheckBox.adjustSize()
        self.detailedScanCheckBox.hide()

        # self.loadingSpinner = Spinner(self.centralwidget)
        # self.loadingSpinner.setGeometry(QtCore.QRect(20, 190, 400, 200))

        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 675, 22))
        self.menubar.setObjectName("menubar")
        self.menuAbout = QtWidgets.QMenu(self.menubar)
        self.menuAbout.setObjectName("menuAbout")
        self.menuReport = QtWidgets.QMenu(self.menubar)
        self.menuReport.setObjectName("menuReport")

        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")

        self.actionExport_to_PDF = QtWidgets.QAction(MainWindow)
        self.actionExport_to_PDF.setObjectName("actionExport_to_PDF")
        self.actionExport_to_PDF.triggered.connect(self.exportReportToPDF)
        self.menuReport.addAction(self.actionExport_to_PDF)

        MainWindow.setStatusBar(self.statusbar)
        self.menubar.addAction(self.menuAbout.menuAction())
        self.menubar.addAction(self.menuReport.menuAction())

        


        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

        #Loading screen
        self.loading_screen = LoadingScreen()
        
    #############################################
    ######## START LOADING ANIMATION ############
    #############################################
    def startLoadingAnimation(self):
        self.movie.start()
        self.loadingLabel.show()
    #############################################
    ######## STOP LOADING ANIMATION ############
    #############################################
    def stopLoadingAnimation(self):
        self.movie.stop()
        self.loadingLabel.hide()

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.networkLabel.setText(_translate("MainWindow", "Input your network here:"))
        self.submitNetworkButton.setText(_translate("MainWindow", "Submit"))
        self.networkValidationLabel.setText(_translate("MainWindow", ""))
        self.menuAbout.setTitle(_translate("MainWindow", "About"))
        self.menuReport.setTitle(_translate("MainWindow", "Report"))
        self.actionExport_to_PDF.setText(_translate("MainWindow", "Export to PDF"))


    #submit input network for validation as a network
    #########################################################
    ######## SUBMIT NETWORK FOR INPUT VALIDATION ############
    #########################################################
    def submitNetworkClick(self):
        global foundIPs
        foundIPs = []
        self.treeView.reset()
        self.treeModel.removeRows(0, self.treeModel.rowCount())
        network = getInput(self.inputNetwork.text())
        if network == 0:
            self.networkValidationLabel.setText("Invalid IP address or network. Try again.")
            self.networkValidationLabel.adjustSize()
            self.networkValidationLabel.repaint()
        else :
            self.networkValidationLabel.setText("Scanning network: " + str(network))
            self.inputNetwork.setText("")
            self.networkValidationLabel.adjustSize()
            self.networkValidationLabel.repaint()
            self.startNetworkScan(network)

    #############################################
    ######## RECIEVE NETWORK SCAN RESULTS########
    ######## ADD RESULTS TO TREE      ############
    #############################################
    def networkScanDone(self):
        global today, currentLine, pdf
        j = 0
        if activeIPs == None:
            pdf.cell(200, 10, "No active IPs found on given network.", ln=currentLine)
            self.show_popup('No active IPs found on given network', 'Scan results', 'info')
            currentLine+=1
        else:
            time = today.strftime("%H:%M:%S.%f")
            pdf.cell(200, 10, f"Network scan completed at {time}", ln=currentLine)
            currentLine+=1
            self.show_popup(f'Scan completed, {len(activeIPs)} open IPs found.', 'Scan results', 'info')

            pdf.cell(200, 10, f"Found {len(activeIPs)} active IPs:", ln=currentLine)
            currentLine+=1

        
        for i in activeIPs or []:
            foundIPs.append(StandardItem(str(i), 11, set_bold=True))
            self.rootNode.appendRow(foundIPs[j])
            j += 1

            pdf.cell(200, 5, f" Active IP: {str(i)}", ln=currentLine)
            currentLine+=1

        self.fullScanCheckBox.show()
        self.detailedScanCheckBox.show()
        self.treeView.setModel(self.treeModel)
        self.treeView.expandAll()
        print(activeIPs)
        self.networkValidationLabel.setText("")
        self.networkValidationLabel.adjustSize()
        self.networkValidationLabel.repaint()
    #do a ping sweep on the network
    #############################################
    ######## START PING SWEEP OF NETWORK ########
    #############################################
    def startNetworkScan(self, network):
        global activeIPs, today, currentLine, pdf

        self.startLoadingAnimation()
        #TODO: if starting a new scan, clear the treeview
        
        #spinner = Spinner()
        #Here trying to run network scan on a worker on a different thread.
        self.thread = QThread()
        self.worker = NetworkScanWorker()
        self.worker.moveToThread(self.thread)

        dateTime = today.strftime("%B %d, %Y %H:%M:%S.%f")

        pdf.cell(200, 10, f"Started scanning network {network} at {dateTime}.", ln=currentLine)
        currentLine+=1

        # self.thread.started.connect(
        #     self.startLoadingAnimation
        # )
        self.thread.started.connect(
            partial(self.worker.run, network)
            )
        
        self.worker.finished.connect(self.thread.quit)
        self.worker.finished.connect(self.worker.deleteLater)
        self.worker.finished.connect(self.thread.deleteLater)
        self.worker.finished.connect(self.stopLoadingAnimation)
        self.worker.finished.connect(self.networkScanDone)


        self.submitNetworkButton.setEnabled(False)
        self.thread.finished.connect(
            partial(self.submitNetworkButton.setEnabled, True)
        )
        
        self.thread.start()
        
        #activeIPs = doPingSweep(network)


    def parseProduct(self, str):
        if("apache".casefold() in str.casefold()):
            return 'apache httpd'
        if('openssh'.casefold() in str.casefold()):
            return 'ssh'
        if("samba".casefold() in str.casefold() or "smb".casefold() in str.casefold()):
            return 'samba'
        return str
        

    #############################################
    ######## DOUBLE CLICK ACTION ON TREE VALUES##
    #############################################
    def doubleClickOnValueFromTree(self, val):
        #self.treeView.collapseAll()
        
        print(f"PRESSED on treeView column {val.column()}, row {val.row()} and value:{val.data()}f")

        firstParent = val.parent()
        if(firstParent.isValid()): #This is not an IP anymore
            grandParent = firstParent.parent()
            if(grandParent.isValid()): #This is a detail of a port
                print("This has a grandparent!")
                clickedValue = val.data()
                portDetails = clickedValue.split(': ')
                if(portDetails[0] == 'product'):
                    
                    self.scan_product_vulnerabilities(self.parseProduct(portDetails[1]), ip=grandParent.data(), port=firstParent.data())

            else: #This is a port of an IP
                print("THIS HAS A PARENT: ", val.parent())
                portsToBeFurtherScanned.append(int(val.data()))
                self.scanPortsDetails(firstParent.data())
        else:
            for ip in foundIPs:
                if (ip.getText() == val.data()):
                    selectedIp = ip
                    if(selectedIp.hasChildren()):
                        selectedIp.removeRows(0,selectedIp.rowCount())
                    break
            foundPorts.clear()
            self.scanPortsSyn(val.data())
        

    #save ports scan result
    #############################################
    ######## PORT SCAN DONE AND ADDED RESULTS TO TREE ############
    #############################################
    def portScanDone(self, selected, resetChildren=False):
        global portsDictionary, foundIPs, foundPorts, portsToBeFurtherScanned, currentLine, pdf
        # if portsDictionary != None:
        #     self.show_popup(f"Ports scan complete. Found {len(portsDictionary)} open ports.", "Scan Results", "info")
        # else:
        #     self.show_popup("Ports scan complete. No ports found.", "Scan Results", "info")
        try:
            for ip in foundIPs:
                if (ip.getText() == selected):
                    selectedIp = ip
                    break
            selectedIp.setIcon(self.cyberIcon)

            j = len(foundPorts)

            for port in portsDictionary or []:
                if (port[0]['product'] != '' or port[0]['version'] != '' or port[0]['extrainfo'] != ''): #This means a detailed scan was made and something was found
                    # for item in self.treeModel.findItems(str(port[1])):
                    #     print("FOUND should be removed")
                    #     self.treeModel.removeRow(item.row())
                    print(f"Looking for duplicates in foundPorts:")
                    printList(foundPorts, 0)
                    duplicateItemIndex = getIndex(foundPorts, str(port[1]))

                    if(duplicateItemIndex != -1): #This means the port was already found but without details and should be updated
                        selectedIp.removeRow(duplicateItemIndex)
                        del foundPorts[duplicateItemIndex]
                        foundPorts.insert(duplicateItemIndex, StandardItem(str(port[1]), 10, set_bold=True))

                        today = datetime.now()
                        dateTime = today.strftime("%B %d, %Y %H:%M:%S.%f")
                        pdf.cell(200, 10, f"Port {str(port[1])} of IP {selectedIp.getText()} was updated with details:", ln=currentLine)
                        currentLine+=1  
                        pdf.cell(200, 5, f" name: {str(port[0]['name'])}", ln=currentLine)
                        currentLine+=1  
                        pdf.cell(200, 5, f" state: {str(port[0]['state'])}", ln=currentLine)
                        currentLine+=1  
                        selectedIp.insertRow(duplicateItemIndex, foundPorts[duplicateItemIndex])
                        foundPorts[duplicateItemIndex].appendRow(StandardItem("name: " + str(port[0]['name']), 10))
                        foundPorts[duplicateItemIndex].appendRow(StandardItem("state: " + str(port[0]['state']), 10))
                        if port[0]['product'] != '':
                            pdf.cell(200, 5, f" product: {str(port[0]['product'])}", ln=currentLine)
                            currentLine+=1  
                            foundPorts[duplicateItemIndex].appendRow(StandardItem("product: " + str(port[0]['product']), 10))
                        if port[0]['version'] != '':
                            pdf.cell(200, 5, f" version: {str(port[0]['version'])}", ln=currentLine)
                            currentLine+=1  
                            foundPorts[duplicateItemIndex].appendRow(StandardItem("version: " + str(port[0]['version']), 10))
                        if port[0]['extrainfo'] != '':
                            pdf.cell(200, 5, f" extrainfo: {str(port[0]['extrainfo'])}", ln=currentLine)
                            currentLine+=1  
                            foundPorts[duplicateItemIndex].appendRow(StandardItem("extrainfo: " + str(port[0]['extrainfo']), 10))
                        print (StandardItem("product: " + str(port[0]['product']), 10).getText())
                    else: #this means the port is newly found
                        foundPorts.append(StandardItem(str(port[1]), 10, set_bold=True))
                        selectedIp.appendRow(foundPorts[j])
                        pdf.cell(200, 10, f"Port {str(port[1])} was found with details:", ln=currentLine)
                        currentLine+=1  

                        pdf.cell(200, 5, f" name: {str(port[0]['name'])}", ln=currentLine)
                        currentLine+=1  
                        pdf.cell(200, 5, f" state: {str(port[0]['state'])}", ln=currentLine)
                        currentLine+=1  
                        foundPorts[j].appendRow(StandardItem("name: " + str(port[0]['name']), 10))
                        foundPorts[j].appendRow(StandardItem("state: " + str(port[0]['state']), 10))
                        if port[0]['product'] != '': 
                            pdf.cell(200, 5, f" product: {str(port[0]['product'])}", ln=currentLine)
                            currentLine+=1  
                            foundPorts[j].appendRow(StandardItem("product: " + str(port[0]['product']), 10))
                        if port[0]['version'] != '': 
                            pdf.cell(200, 5, f" version: {str(port[0]['version'])}", ln=currentLine)
                            currentLine+=1  
                            foundPorts[j].appendRow(StandardItem("version: " + str(port[0]['version']), 10))
                        if port[0]['extrainfo'] != '': 
                            pdf.cell(200, 5, f" extrainfo: {str(port[0]['extrainfo'])}", ln=currentLine)
                            currentLine+=1  
                            foundPorts[j].appendRow(StandardItem("extrainfo: " + str(port[0]['extrainfo']), 10))
                else: #this means the port is found without any details
                    try:
                        pdf.cell(200, 10, f"Port {str(port[1])} was found with details:", ln=currentLine, )
                        currentLine+=1  
                        foundPorts.append(StandardItem(str(port[1]), 10))
                        selectedIp.appendRow(foundPorts[j])
                        pdf.cell(200, 5, f" name: {str(port[0]['name'])}", ln=currentLine)
                        currentLine+=1  
                        pdf.cell(200, 5, f" state: {str(port[0]['state'])}", ln=currentLine)
                        currentLine+=1  
                        foundPorts[j].appendRow(StandardItem("name: " + str(port[0]['name']), 10))
                        foundPorts[j].appendRow(StandardItem("state: " + str(port[0]['state']), 10))
                        if(str(port[0]['state']) == 'open' and self.detailedScanCheckBox.isChecked()):
                            portsToBeFurtherScanned.insert(0, port[1])
                    except Exception as ex:
                        print(ex)

                j += 1

            self.treeView.resizeColumnToContents(0)

            self.treeView.setModel(self.treeModel)
            self.treeView.expandToDepth(0)
        except Exception as ex:
                    print('Exception in portScanDone: ', ex)

    #click function for scan on specific ip to look for ports
    ###################################################################
    ######## START PORT SCAN OF ITEM DOUBLE CLICKED ON TREE ############
    #####################################################################
    def scanPortsSyn(self, selected):

        global portsToBeFurtherScanned, currentLine, pdf, foundIPs
        print(selected)
        # portsDictionary = scanPorts(selected)
        for ip in foundIPs:
            if (ip.getText() == selected):
                selectedIp = ip
                break
        selectedIp.setIcon(self.loadIcon)

        self.thread = QThread()
        self.worker = PortScannerWorker()
        self.worker.moveToThread(self.thread)

        if (self.fullScanCheckBox.isChecked()):
            today = datetime.now()
            dateTime = today.strftime("%B %d, %Y %H:%M:%S.%f")
            pdf.cell(200, 10, f"Starting full port scan on ip {selected} at {dateTime}", ln=currentLine)
            currentLine+=1  
            self.thread.started.connect(
                partial(self.worker.run, selectedIP=selected, portStart=1, portEnd=1000, scanArgs='-sS')
                )
        else:

            today = datetime.now()
            dateTime = today.strftime("%B %d, %Y %H:%M:%S.%f")
            topNrPorts = 10
            pdf.cell(200, 10, f"Starting top {topNrPorts} port scan on ip {selected} at {dateTime}", ln=currentLine)
            currentLine+=1  
            portList = f'--top-ports {topNrPorts} '
            print("TOP PORTS")
            self.thread.started.connect(
                partial(self.worker.run, selectedIP=selected, portList=portList, scanArgs='-sS')
                )
        #TODO: fac sa nu apara checkboxu numa dupa ce apar IPurile

        
        # self.worker.finished.connect(self.thread.quit)
        self.worker.progress.connect(
                partial(self.portScanDone, selected)
                )
        # self.worker.finished.connect(self.worker.stop)
        self.worker.finished.connect(self.thread.quit)
        self.worker.finished.connect(self.thread.wait)

        

        self.worker.finished.connect(self.stopLoadingAnimation)
        
        self.worker.finished.connect(
            partial(self.scanPortsDetails, selected=selected)
        )
        self.startLoadingAnimation()
        self.thread.start()
            

    def scanPortsDetails(self, selected):
        global portsToBeFurtherScanned
        if(len(portsToBeFurtherScanned) > 0):

            self.thread = QThread()
            self.worker = PortScannerWorker()
            self.worker.moveToThread(self.thread)

            print(portsToBeFurtherScanned)
            

            self.thread.started.connect(
                partial(self.worker.run, selectedIP=selected, portList=portsToBeFurtherScanned.pop(), scanArgs='-n -sV -A')
                )
            self.worker.finished.connect(self.thread.quit)
            self.worker.finished.connect(self.thread.wait)
            self.worker.progress.connect(
                    partial(self.portScanDone, selected)
                    )

            self.worker.finished.connect(self.stopLoadingAnimation)

            if(len(portsToBeFurtherScanned) > 0):
                self.worker.finished.connect(
                    partial(self.scanPortsDetails, selected))
                
            self.startLoadingAnimation()
            self.thread.start()
        else:
            pass
    

    def vulnScanDone(self, vuln_list, expl_list, port):
        portIndex = getIndex(foundPorts, port)
        print(port)
        printList(foundPorts, 0)
        print(portIndex)

        for vuln in vuln_list or []:
            pdf.multi_cell(0, 5, f"{vuln.__str__()}")

            if(portIndex != -1):
                foundPorts[portIndex].appendRow(StandardItem("Vulnerability: \n" + vuln.__str__(), 10, color=QColor(128, 12, 32, 200)))
            # print(vuln.__str__())
        for expl in expl_list or []:
            pdf.multi_cell(0, 5, f"{expl.__str__()}")
            print(expl.getUrl())
            if(portIndex != -1):
                foundPorts[portIndex].appendRow(StandardItem("Exploit: \n" + expl.getUrl() + expl.__str__(), 10, color=QColor(250, 12, 12, 220)))

            # print(expl.__str__())
        
        self.treeView.resizeColumnToContents(0)
        self.treeView.setModel(self.treeModel)

    def scan_product_vulnerabilities(self, product, ip, port, version="*.*"):
        global currentLine, pdf, foundPorts
        print("PRODUCT TO SCAN FOR VULN: ", product)
        today = datetime.now()
        dateTime = today.strftime("%B %d, %Y %H:%M:%S.%f")
        pdf.multi_cell(0, 10, f"Vulnerabilities and Exploits search started on port {port} of IP {ip} at {dateTime}")
        currentLine+=1


        self.startLoadingAnimation()


        self.thread = QThread()
        self.worker = VulnScannerWorker()
        self.worker.moveToThread(self.thread)

        self.thread.started.connect(
            partial(self.worker.run, product=product, version=version)
            )
        self.worker.finished.connect(self.thread.quit)
        self.worker.finished.connect(self.thread.wait)
        

        self.worker.finished.connect(self.stopLoadingAnimation)

        self.worker.finished.connect(
            partial(self.vulnScanDone, port=port)
        )
        self.thread.start()
        

    #popup function, takes arg the message, title and icon style
    #############################################
    ######## POPUP FUNCTION THAT GETS AS PARAMS
    # ###### THE MESSAGE, TITLE AND ICON STYLE
    #  ##### ONLY HAS OK BUTTON FOR NOW ############
    #############################################
    def show_popup(self, message, title, icon):
        msg = QMessageBox()
        msg.setWindowTitle(title)
        msg.setText(message)
        match icon:
            case 'warning':
                msg.setStandardButtons(QMessageBox.Ok)
                msg.setIcon(QMessageBox.Warning)
            case 'info':
                msg.setIcon(QMessageBox.Information)
                msg.setStandardButtons(QMessageBox.Ok)
            case 'question':
                msg.setStandardButtons(QMessageBox.Yes | QMessageBox.No)
                msg.setIcon(QMessageBox.Question)
            case default:
                pass

        msg.buttonClicked.connect(self.popup_button)

        x = msg.exec_()

    def popup_button(self, btn):
        print(btn.text())
        match btn.text():
            case '&Yes':
                self.exportReport()
            case default:
                pass

    def exportReport(self):
        global pdf
        print("SHOULD EXPORT")
        today = datetime.now()
        dateTime = today.strftime("%-m-%-d-%M%S")
        pdf.output(f"networkscan-{dateTime}.pdf").encode('utf-8')
        self.clearAll()
    
    def exportReportToPDF(self):
        global pdf

        self.show_popup('Exporting report to pdf.\nBuilding a report will clear everything. Do you wish to continue?', 'Building report', 'question')

        

    def clearAll(self):
        global pdf, activeIPs, foundIPs, foundPorts, portsDictionary, portsToBeFurtherScanned

        activeIPs = []
        foundIPs = []
        foundPorts = []
        portsDictionary = {}
        portsToBeFurtherScanned = []
        self.treeModel.removeRows(0, self.treeModel.rowCount())

        pdf = FPDF()
        currentLine = 1
        pdf.add_page()
        pdf.set_font("Arial", size=13)

        pdf.cell(200,10, txt="Scan Report", ln=currentLine, align='C')
        currentLine+=1

        self.treeView.resizeColumnToContents(0)



#################################################################################
    ######## WORKER CLASS THAT HELPS SEND SPECIFIC TASKS TO DIFFERENT THREADS###
    # HELPS WITH THE LOADING ANIMATION AND RESPONSITIVITY OF GUI    ############
    ############################################################################
class NetworkScanWorker(QObject):
    finished = pyqtSignal()
    progress = pyqtSignal(int)

    def __init__(self):
        super().__init__()

    
    def run(self, network):
        global activeIPs
        activeIPs = doPingSweep(network)
        self.finished.emit()

class VulnScannerWorker(QObject):
    finished = pyqtSignal(list, list)

    def __init__(self):
        super().__init__()

    def run(self, product, version=""):

        (vuln_list, expl_list) = software_scanner(product=product, version=version) or ([], [])
        self.finished.emit(vuln_list, expl_list)

class PortScannerWorker(QObject):
    finished = pyqtSignal()
    progress = pyqtSignal()

    def __init__(self):
        super().__init__()
    
    def run(self, selectedIP, portStart=0, portEnd=1, portList=[], scanArgs=''):
        global portsDictionary
        try:
            portIncrement = 100
            while (portStart < portEnd):
                portsDictionary = scanPorts(selectedIP, portStart, portStart+portIncrement, portList=portList, scanArgs=scanArgs)
                self.progress.emit()
                # time.sleep(1)
                portStart += portIncrement
                portIncrement += 200
            self.finished.emit()
            # self.disconnect()

        except Exception as ex:
            print("Exception thrown in run of portScanner worker: ", ex)


if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())
